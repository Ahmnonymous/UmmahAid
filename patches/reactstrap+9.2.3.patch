diff --git a/node_modules/reactstrap/lib/Tooltip copy.js b/node_modules/reactstrap/lib/Tooltip copy.js
new file mode 100644
index 0000000..951ea60
--- /dev/null
+++ b/node_modules/reactstrap/lib/Tooltip copy.js	
@@ -0,0 +1,34 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _react = _interopRequireDefault(require("react"));
+var _classnames = _interopRequireDefault(require("classnames"));
+var _TooltipPopoverWrapper = _interopRequireWildcard(require("./TooltipPopoverWrapper"));
+var _utils = require("./utils");
+function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
+function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+const defaultProps = {
+  placement: 'top',
+  autohide: true,
+  placementPrefix: 'bs-tooltip',
+  trigger: 'hover focus'
+};
+function Tooltip(props) {
+  const arrowClasses = (0, _classnames.default)('tooltip-arrow', props.arrowClassName);
+  const popperClasses = (0, _classnames.default)('tooltip', 'show', props.popperClassName);
+  const classes = (0, _classnames.default)('tooltip-inner', props.innerClassName);
+  const _props = (0, _utils.addDefaultProps)(defaultProps, props);
+  return /*#__PURE__*/_react.default.createElement(_TooltipPopoverWrapper.default, _extends({}, _props, {
+    arrowClassName: arrowClasses,
+    popperClassName: popperClasses,
+    innerClassName: classes
+  }));
+}
+Tooltip.propTypes = _TooltipPopoverWrapper.propTypes;
+var _default = Tooltip;
+exports.default = _default;
\ No newline at end of file
diff --git a/node_modules/reactstrap/lib/Tooltip.js b/node_modules/reactstrap/lib/Tooltip.js
index 951ea60..127c6d1 100644
--- a/node_modules/reactstrap/lib/Tooltip.js
+++ b/node_modules/reactstrap/lib/Tooltip.js
@@ -7,28 +7,51 @@ exports.default = void 0;
 var _react = _interopRequireDefault(require("react"));
 var _classnames = _interopRequireDefault(require("classnames"));
 var _TooltipPopoverWrapper = _interopRequireWildcard(require("./TooltipPopoverWrapper"));
-var _utils = require("./utils");
-function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
-function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+function _getRequireWildcardCache(nodeInterop) {
+  if (typeof WeakMap !== "function") return null;
+  var cacheBabelInterop = new WeakMap();
+  var cacheNodeInterop = new WeakMap();
+  return (_getRequireWildcardCache = function (nodeInterop) {
+    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+  })(nodeInterop);
+}
+
+function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { cache.set(obj, newObj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
 function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
 function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
-const defaultProps = {
-  placement: 'top',
-  autohide: true,
-  placementPrefix: 'bs-tooltip',
-  trigger: 'hover focus'
-};
-function Tooltip(props) {
-  const arrowClasses = (0, _classnames.default)('tooltip-arrow', props.arrowClassName);
-  const popperClasses = (0, _classnames.default)('tooltip', 'show', props.popperClassName);
-  const classes = (0, _classnames.default)('tooltip-inner', props.innerClassName);
-  const _props = (0, _utils.addDefaultProps)(defaultProps, props);
-  return /*#__PURE__*/_react.default.createElement(_TooltipPopoverWrapper.default, _extends({}, _props, {
-    arrowClassName: arrowClasses,
-    popperClassName: popperClasses,
-    innerClassName: classes
-  }));
+
+// ðŸ‘‡ Use destructuring with defaults instead of defaultProps
+function Tooltip({
+  placement = "top",
+  autohide = true,
+  placementPrefix = "bs-tooltip",
+  trigger = "hover focus",
+  arrowClassName,
+  popperClassName,
+  innerClassName,
+  ...rest
+}) {
+  const arrowClasses = (0, _classnames.default)("tooltip-arrow", arrowClassName);
+  const popperClasses = (0, _classnames.default)("tooltip", "show", popperClassName);
+  const classes = (0, _classnames.default)("tooltip-inner", innerClassName);
+
+  return /*#__PURE__*/_react.default.createElement(
+    _TooltipPopoverWrapper.default,
+    _extends(
+      {
+        placement,
+        autohide,
+        placementPrefix,
+        trigger,
+        arrowClassName: arrowClasses,
+        popperClassName: popperClasses,
+        innerClassName: classes
+      },
+      rest
+    )
+  );
 }
+
 Tooltip.propTypes = _TooltipPopoverWrapper.propTypes;
 var _default = Tooltip;
 exports.default = _default;
